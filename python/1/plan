Time: 100 mins

*Explain syntax as you type*

- Class definition:
    - Going to create a Vehicle class
    - New file, vehicle.py, could be dinosaur.py, but more understandable this way, other languages require it
    - Code we write for a class is called the class definition
    - Syntax:
        - class keyword, name of class of objects
        - In brackets, object, will explain more later, think of it as explicitly saying we're creating a class of objects
        - Capital letter at start of class not necessary, but convention. Other languages require it.
        - Colon + indent:
            - Class definition is example of a "block of code"
            - Other examples are the code inside loops and conditions
            - Opening line ends in colon and all code inside is indented
            - Helps keep things looking neat and Python will complain without it

- Constructor:
    - Next part of class definition is a method called the constructor
    - Sets default values of instance's data fields, *examples*:
        - Number of wheels Vehicle has
        - Current speed of Vehicle
    - Automatically gets called when we create an instance of the class, *explain with Vehicle*
    - Method's name is always "__init__"
    - Syntax:
        - Other methods will use exactly same syntax
        - def keyword, name of method
        - In brackets, the arguments to the method, will explain self shortly
        - *write super call*
        - *write first line of constructor too, currSpeed*
        - First, colon and indent again, because a method is also a block of code. Notice that indents "build up", indents always same size
        - self:
            - *Ask someone to guess what self is*
            - Refers to the instance of the class
            - First argument to every method
            - We use it here to set default values of data fields
        - super call, will make a lot more sense when I explain subclassing, for now, it is magic
        - Data fields
            - To create data field, self, dot, name of the field, then just assign to it
            - To access the instance, always self then dot, then what we're accessing
            - This way of accessing is called dot syntax
            - Note: No need for semicolon at the end of lines. Also, arguments can be same name as data fields
            - So other data fields:
                - Number of wheels - integer
                - inDisguise - Boolean, True or False, remember the capitals
                - modelName - String, just put "" or '' around it
                - *Ask for others*

- The Python Interpreter:
    - Test our class
    - Ensure we're in the same directory as vehicle.py
    - The interpreter:
        - Runs your Python program
        - Can also write code directly into it
        - Technical sidetrack, *ask if anyone's interested, see how time is going*
            - Sometimes we compile, i.e. transform straight to machine code
            - Opposite end, we interpret, we read a line of code and perform an action based upon that, interpreter knows what to do
            - In between, bytecode compilation, transform code into bytecode, which is understood by a "virtual machine", performs actions based upon bytecode
            - Same language can be implemented in different ways, e.g. there are interpreters for C, normally we think of it as compiled
            - Similarly different implementations of Python use different approaches, most common is bytecode compilation
    - import, for now think of it as loading the file, no .py extension
    - Instantiating a class:
        - First, write name of file we import, then dot, then write name of class then brackets
        - File at start required because that is where class was defined
        - Assign to a variable, v, this is just like normal code
        - Automatically calls __init__
    - Accessing the instance:
        - Again, we use dot syntax
        - v is a Vehicle, so we can do v dot data field, *show example*
        - No need for file name at start, because v was defined here, not in that file
        - Interpreter automatically prints the value
        - Do the same with v, shows the class and a hex number. This is an id that Python associates with every object, and in the most common version of Python, its location in memory
    - Later we'll see how to do all this automatically

- Arguments to constructor:
    - Current constructor is not flexible
    - Add more arguments to the constructor for all data fields
    - *Demonstrate in interpreter, reiterate need for file name at start for constructor, show error when missing arguments*

- *Ask if any questions so far*

- Exercise 1a:
    - In a new file, write a new class definition for the SpeedCamera class
    - In its constructor, take 4 arguments: 
        - A speed limit for vehicles with < 2 wheels
        - For 2 wheel vehicles
        - For 3 wheel vehicles 
        - And 4 or more wheels vehicles
    - Store all of them in data fields with understandable names
    - Create a SpeedCamera in interpreter, prints its limit, change its limit
    - *Demonstrate and explain*

- Methods, print and conditions:
    - Make it do something, add other methods, getMaxSpeed, isTransformer, printMe
    - getMaxSpeed syntax:
        - def followed by method name
        - self must be the first argument
        - colon and indent
        - Use random formula to convert speed to maxSpeed, demonstrate operators, especially powers
        - return keyword is used for returning values from a method
    - isTransformer syntax:
        - Same method syntax, def, method name, self
        - Same colon and indent
        - Now we just return inDisguise, if it is inDisguise, it is a transformer
    - printMe syntax:
        - Same again, def, method name, self
        - *Include 3 Boolean arguments to print each type of info*
        - if statement == if keyword, then condition, then the colon and indent, because this is a block of code

        - Conditions are nested by adding another indent
        - Conditions can use True/False and can call methods, *demonstrate with isTransformer()*
        - No need for brackets around condition
        - Print syntax here is print keyword followed by a string (in quotes)
        - Else is used if the if is not satisfied

        - Print syntax for variable is print keyword followed by variable name (no quotes)
        - *Demonstrate with printModel*

        - Print syntax to print string and variable with space in between is print followed by comma-separated items
        - *Demonstrate with printWheels and printSpeed*

        - Conditions can use ==, >, <, >=, <=
        - *Use this to print what the vehicle might be with if, elif, else, e.g. car, bike, trike*
        - Note: elif allows you to check another condition, will keep going until a match is found or an else. If no else, none executed
        - Note: each new print starts on a new line

- Calling methods:
    - *Start interpreter, import, create Vehicle, call each method*
    - Note: did not pass in any self argument, no need to do this when method is called from an instance of the Class
    - Alternative way of calling methods:
        - file name, dot, class name, dot, method name, then pass in a "self", i.e. an instance
        - We need file name and class name because that is where the method is defined
        - No need to use this method of calling, but keep in mind how we use dot syntax to access things defined elsewhere

- Exercise 1b:
    - vehicle.py has what we've written up to here
    - Write an isOverLimit method in SpeedCamera:
        - Takes a Vehicle as an argument
        - Checks its number of wheels and its speed (use the dot syntax to read these)
        - If it is over the limit for that number of wheels, prints "Over limit by: " and the amount it is over limit by, and returns True
        - If not over limit, print "Under limit by: ", amount it is under limit by, and returns False
    - Create some Vehicles in interpreter, create a SpeedCamera, test it out
    - *Demonstrate and explain solution*

- Exercise 1c:
    - Pygame example, not going into specifics, but more fun
    - *Run game, then open file*:
        - Going to implement space invaders-like thing. Some code you won't recognise, but ignore it, will do what we can with existing skills
        - Current Invader constructor, x and y control position (0,0) is top-left, image is loaded by filename, direction controls which way the invader moves
        - You will need to modify the constructor and its arguments
        - createInvaders uses a for loop, will explain the syntax later, loops 10 times to create all the invaders, see how i becomes a variable
        - update gets called once every frame, as you can guess it moves the invaders and switches direction once it hits border
        - You'll notice syntax for comments here, just put hash in front of the line
        - Tasks:
            - Create 3 rows of 10 invaders, like in Space Invaders
            - Stop the invaders just before hitting edge of screen, rather than going through it
            - Make each row of invaders have a different image, *show images available*
            - Make the invaders move down and speed up when they hit either border

- and, or, not:
    - *Ask who is familiar with Boolean operations*
    - Can combine conditions with Python's Boolean operations
    - *Change code from exercise 1b and Vehicle to demonstrate*

- Subclassing:
    - Remember, subclassing == create specialised versions based on a parent class
    - Will create subclass OptimusPrime, *ask if everyone knows Optimus Prime*
    - To create subclass, same class keyword, but brackets and parent class afterwards
    - Now it automatically has same methods
    - Remember earlier, object in brackets, now Vehicle:
        - So we were really saying we're subclassing object
        - object is called a primitive, sort of the very base class that other objects are based upon
        - *Draw inheritance arrows on board*
    - Not going to add any code, just going to put pass. Pass does nothing, it's used to stop Python complaining when you have no code inside a block
    - Let's try creating one
    - *Demonstrate creating without arguments, fails*
    - Has inherited the __init__ constructor, must provide same arguments
    - *Demonstrate with correct arguments for an OptimusPrime, call getMaxSpeed, works*
    - This class works, but usually only subclass if you want to change or add behaviours, otherwise you'd just use a different constructor
    - *Add a defeatVillain method and villain name to a new __init__, set only their data fields*
    - We can add new methods and data fields and constructor arguments to the subclass
    - *Demonstrate creating and call getMaxSpeed, fails*
    - If you create your own init, i.e. override the parent's init, the parent's is no longer called, we must do it manually, same goes for any overridden method
    - This is what the super method does, allows us to call methods from the parent class:
        - It's like a method, takes 2 arguments, then allows us to call parent class's methods
        - Here, use it to call parent's constructor
        - And in Vehicle, we used the same line to call its parent's constructor, which was object
        - Can use this to call any of parent's methods
    - Super constructor will set up some data fields, we set up the rest
    - *Demonstrate in interpreter, then demonstrate polymorphism by using SpeedCamera on OptimusPrime*
    - *Ask if anyone can explain why this works*
    - OptimusPrimes are of type OptimusPrime, but also of type Vehicle, so SpeedCamera can understand them
    - *Override maxSpeed method and demonstrate*
    - Can override existing behaviours just by writing method with same name
    - *Call parent's maxSpeed and demonstrate*
    - As mentioned earlier, super can be used to call any of parent's methods
    - *Change type returned by maxSpeed to "banana", demonstrate error*
    - Other languages would prevent you overriding and returning a different type, will explain why Python is different shortly
    - *Ask if anyone knows another mechanism to prevent this*
    - Private, would prevent us overriding. Would use it because another class, SpeedCamera, depends upon maxSpeed's output
    - Will explain in code soon

- Exercise 1d:
    - Update method controls movement
    - Task:
        - In same file create a subclass of Invader called VerticalInvader
        - Let its constructor take x and y, but manually choose an image to pass to super
        - Override update, make it move up and down rather than left-to-right, don't worry about increasing speed/moving down at borders
        - Make 1 row of invaders into VerticalInvaders
        - Then add other subclasses, other movements, e.g.:
            - Zig-zag
            - Square
    - *Demonstrate solution, DarthInvader, diamond?*

- *Ask: Can anyone guess what 1c and 1d were for?*
- Demonstrate constructors vs. subclassing
- When it is a simple difference, e.g. different images, just put it in constructor
- For complicated differences, e.g. different movement, subclass and override the method
- It will depend on how you want to design it
